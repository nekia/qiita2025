<!DOCTYPE html>
<html lang="ja">
<!--
    Raspberry Pi ã® Chromium ã§çµµæ–‡å­—ã‚’è¡¨ç¤ºã™ã‚‹ã«ã¯ã€ä»¥ä¸‹ã®ã‚³ãƒãƒ³ãƒ‰ã§ãƒ•ã‚©ãƒ³ãƒˆã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã—ã¦ãã ã•ã„ï¼š
    
    sudo apt-get update
    sudo apt-get install fonts-noto-color-emoji
    
    ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«å¾Œã€Chromium ã‚’å†èµ·å‹•ã—ã¦ãã ã•ã„ã€‚
-->
<head>
    <meta charset="UTF-8" />
    <title>ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒœãƒ¼ãƒ‰ãƒ»ãƒ•ã‚©ãƒˆãƒ•ãƒ¬ãƒ¼ãƒ </title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
        /* ãƒ™ãƒ¼ã‚¹è¨­å®šï¼šFHDå‰æã§æ–‡å­—ã‚’ã‹ãªã‚Šå¤§ãã‚ã« */
        html,
        body {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Yu Gothic", "Noto Sans JP", "Segoe UI Emoji", "Apple Color Emoji", "Noto Color Emoji", sans-serif;
            background-color: #2a2a2a;
            /* æ•°å­—ã®ãƒ•ã‚©ãƒ³ãƒˆãƒãƒªã‚¢ãƒ³ãƒˆã‚’ç„¡åŠ¹åŒ– */
            font-variant-numeric: normal;
            font-feature-settings: normal;
            -webkit-font-feature-settings: normal;
        }

        body {
            display: flex;
            flex-direction: column;
        }

        /* å…¨ã¦ã®è¦ç´ ã§æ•°å­—ã®ã‚¹ã‚¿ã‚¤ãƒ«ã‚’çµ±ä¸€ */
        * {
            font-variant-numeric: normal !important;
            font-feature-settings: normal !important;
            -webkit-font-feature-settings: normal !important;
        }

        /* çµµæ–‡å­—ã‚’ç¢ºå®Ÿã«è¡¨ç¤ºã•ã›ã‚‹ãŸã‚ã®è¨­å®š */
        @font-face {
            font-family: 'EmojiFont';
            src: local('Noto Color Emoji'),
                 local('Segoe UI Emoji'),
                 local('Apple Color Emoji'),
                 local('Android Emoji'),
                 local('Noto Emoji'),
                 local('EmojiOne Color'),
                 local('Twemoji Mozilla');
            unicode-range: U+1F300-1F9FF, U+2600-26FF, U+2700-27BF;
        }

        /* ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆå…¨ä½“ï¼šä¸Šéƒ¨ãƒãƒ¼ + ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ + ä¸‹éƒ¨ãƒŠãƒ“ */
        .app {
            display: flex;
            flex-direction: column;
            height: 100vh;
            width: 100vw;
        }

        .top-bar {
            flex: 0 0 auto;
            padding: 0.8rem 1.5rem;
            background-color: #1a1a1a;
            color: #e0e0e0;
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 2.25rem;
            border-bottom: 1px solid #444;
            /* å¤§ãã‚ */
        }

        .top-bar__left {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .top-bar__badge {
            background-color: #8b4513;
            color: #fff;
            border-radius: 999px;
            padding: 0.2rem 0.8rem;
            font-size: 3.6rem; /* æ–‡å­—ã‚µã‚¤ã‚ºã‚’2å€ */
            display: none; /* æœªå›ç­”ãŒã‚ã‚‹ã¨ãã ã‘è¡¨ç¤º */
            align-items: center;
            gap: 0.6rem;
        }

        .unread-icon {
            font-size: 3.6rem; /* ã‚¢ã‚¤ã‚³ãƒ³ã¯æ®ãˆç½®ãï¼ˆå‰ã®å€¤ã«æˆ»ã™ï¼‰ */
            line-height: 1;
        }

        .top-bar__right {
            font-size: 1.8rem;
            opacity: 0.7;
            display: flex;
            align-items: center;
            gap: 0.8rem;
        }

        .top-bar__action {
            font-size: 1.6rem;
            padding: 0.4rem 0.9rem;
            border-radius: 999px;
            border: 2px solid #bbb;
            background: #fff;
            color: #444;
            cursor: pointer;
        }

        .top-bar__action:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .content {
            flex: 1 1 auto;
            display: flex;
            flex-direction: column;
            padding: 0;
            box-sizing: border-box;
            overflow: hidden;
            /* ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ç¦æ­¢ï¼ˆèª¤æ“ä½œé˜²æ­¢ã‚¤ãƒ¡ãƒ¼ã‚¸ï¼‰ */
        }

        /* å…±é€šã®å¤§ããªã‚«ãƒ¼ãƒ‰æ  */
        .panel {
            flex: 1 1 auto;
            border-radius: 0;
            background-color: #3a3a3a;
            box-shadow: none;
            padding: 0.8rem 0.5rem;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            color: #e0e0e0;
        }

        /* ===== ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ç”»é¢ ===== */

        .message-header {
            flex: 0 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 1rem;
            font-size: 2.4rem;
        }

        .message-header__left {
            display: flex;
            align-items: center;
            gap: 0.8rem;
        }

        .avatar {
            width: 9rem;
            height: 9rem;
            border-radius: 50%;
            background-color: #5a4a3a;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 4.8rem;
            font-weight: bold;
            color: #d4c5b0;
        }

        .sender-name {
            font-weight: bold;
            color: #d4c5b0;
            font-size: 4.8rem;
        }

        .message-time {
            font-size: 3.9rem;
            color: #999;
        }

        .message-body-wrapper {
            flex: 1 1 auto;
            position: relative;
            display: flex;
        }

        .message-body {
            flex: 1 1 auto;
            height: 52vh;
            margin: 0.5rem 0;
            padding: 1.5rem 6.5rem;
            border-radius: 0;
            background-color: #2a2a2a;
            border: none;
            font-size: 6.6rem;
            /* æœ¬æ–‡ã¯ã‹ãªã‚Šå¤§ãã */
            line-height: 1.6;
            color: #e0e0e0;
            overflow-y: auto;
            /* ä¸‡ä¸€é•·æ–‡ã§ã‚‚ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã¯å¯èƒ½ã«ï¼ˆæ™®æ®µã¯éš ã‚Œã‚‹æƒ³å®šï¼‰ */
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .message-body--image-only .message-image {
            max-height: 100%;
        }

        .message-body--has-text .message-image {
            max-height: 60%;
        }

        .message-image {
            width: 100%;
            max-height: 100%;
            object-fit: contain;
            background-color: #1a1a1a;
            border-radius: 0.8rem;
        }

        .message-text {
            white-space: pre-wrap;
            word-break: break-word;
        }

        .message-footer {
            flex: 0 0 auto;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            margin-top: 1rem;
            font-size: 2.4rem;
        }

        .response-buttons {
            display: flex;
            gap: 1.5rem;
            justify-content: center;
            flex-wrap: wrap;
            row-gap: 1.5rem;
        }

        .nav-buttons {
            display: flex;
            gap: 1.5rem;
            justify-content: center;
        }

        .nav-buttons--overlay {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 1rem;
            pointer-events: none;
            z-index: 2;
        }

        .nav-buttons--overlay .btn {
            pointer-events: auto;
        }

        .response-status-overlay {
            position: absolute;
            left: 50%;
            bottom: 0;
            transform: translateX(-50%);
            z-index: 3;
            pointer-events: none;
            background-color: rgba(26, 26, 26, 0.85);
            padding: 0.4rem 1.2rem 0.6rem;
            border-radius: 999px;
            border: 1px solid #3a3a3a;
        }

        .btn {
            border: none;
            border-radius: 999px;
            padding: 1rem 2rem;
            font-size: 2.4rem;
            cursor: pointer;
            min-width: 18rem;
            min-height: 5.25rem;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.15);
            user-select: none;
        }

        .btn-large {
            font-size: 2.7rem;
            padding: 1.8rem 3.75rem;
            min-width: 24rem;
        }

        .btn-primary {
            background-color: #5a4a3a;
            color: #e0e0e0;
        }

        .btn-primary:hover {
            background-color: #6a5a4a;
        }

        .btn-secondary {
            background-color: #4a4a4a;
            color: #d0d0d0;
        }

        .btn-secondary:hover {
            background-color: #5a5a5a;
        }

        .btn-success {
            background-color: #3d5a3d;
            color: #e0e0e0;
        }

        .btn-success:hover {
            background-color: #4d6a4d;
        }

        .btn-disabled {
            background-color: #555;
            color: #888;
            cursor: default;
            box-shadow: none;
            opacity: 0.5;
        }
        
        .btn-disabled:hover {
            background-color: #555;
        }

        .btn-selected {
            border: 3px solid #b6f3b6;
            box-shadow: 0 0 0 4px rgba(138, 182, 138, 0.35), 0 6px 12px rgba(0, 0, 0, 0.25);
            transform: scale(1.02);
        }

        .status-text {
            text-align: center;
            font-size: 2.25rem;
            color: #8ab68a;
        }

        .response-status-answered {
            color: #8ab68a;
            font-weight: bold;
        }

        .response-status-unanswered {
            color: #ff9800;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        .unanswered-badge {
            background-color: #ff9800;
            color: #fff;
            padding: 0.3rem 0.8rem;
            border-radius: 999px;
            font-size: 1.8rem;
        }

        /* ===== ãƒ•ã‚©ãƒˆãƒ•ãƒ¬ãƒ¼ãƒ ç”»é¢ ===== */

        .photo-frame {
            flex: 1 1 auto;
            border-radius: 0;
            background-color: #000;
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            cursor: pointer;
            user-select: none;
        }

        .photo-placeholder {
            font-size: 3.6rem;
            text-align: center;
            opacity: 0.9;
        }

        .photo-info {
            position: absolute;
            bottom: 1rem;
            left: 1rem;
            background-color: rgba(0, 0, 0, 0.6);
            padding: 0.8rem 1.2rem;
            border-radius: 16px;
            font-size: 2.1rem;
        }

        .photo-image {
            width: 100%;
            height: 100%;
            object-fit: contain;
            /* ç¸¦æ¨ªæ¯”ã‚’ç¶­æŒã—ã¦ç”»é¢ã„ã£ã±ã„ã«è¡¨ç¤º */
        }

        .message-indicator {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background-color: rgba(139, 69, 19, 0.9);
            padding: 0.8rem 1.2rem;
            border-radius: 16px;
            font-size: 4.5rem; /* æ–‡å­—ã‚µã‚¤ã‚ºã‚’2å€ */
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: #fff;
        }

        .message-indicator .unread-icon {
            font-size: 4.5rem; /* ã‚¢ã‚¤ã‚³ãƒ³ã¯æ®ãˆç½®ãï¼ˆå‰ã®å€¤ã«æˆ»ã™ï¼‰ */
        }

        /* ===== ä¸‹éƒ¨ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ãƒãƒ¼ ===== */

        .bottom-nav {
            flex: 0 0 auto;
            display: flex;
            justify-content: space-around;
            align-items: stretch;
            background-color: #1a1a1a;
            border-top: 1px solid #444;
            padding: 0.4rem 0.5rem;
            box-sizing: border-box;
        }

        .bottom-nav__button {
            flex: 1 1 0;
            margin: 0 0.3rem;
            border-radius: 999px;
            border: none;
            font-size: 2.4rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 0.6rem 0.3rem;
            background-color: #3a3a3a;
            color: #aaa;
            cursor: pointer;
            user-select: none;
        }

        .bottom-nav__button span {
            display: block;
        }

        .bottom-nav__button--active {
            background-color: #5a4a3a;
            color: #e0e0e0;
        }

        .bottom-nav__icon {
            font-size: 3rem;
            margin-bottom: 0.2rem;
        }

        /* ã‚·ãƒ³ãƒ—ãƒ«ãªãƒ•ã‚§ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆ */
        .screen {
            display: none;
            height: 100%;
        }

        .screen.active {
            display: flex;
            flex-direction: column;
        }

        /* ã‚ˆã‚Šå¤§ããªç”»é¢ã§ã‚‚å…¨å¹…è¡¨ç¤º */
        @media (min-width: 1920px) {
            .content {
                max-width: 100%;
                margin: 0;
            }
        }
    </style>
</head>

<body>
    <div class="app">
        <!-- ä¸Šéƒ¨ãƒãƒ¼ -->
        <div class="top-bar">
            <div class="top-bar__left">
                <span>ğŸ‘µ ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒœãƒ¼ãƒ‰</span>
                <span class="top-bar__badge" id="topUnreadBadge">
                    <span class="unread-icon" aria-hidden="true">ğŸ—¨ï¸</span>
                    <span id="topUnreadBadgeText">æ–°ç€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ 1ä»¶</span>
                </span>
            </div>
            <div class="top-bar__right">
                <button class="top-bar__action" id="btnEnableSound" type="button">
                    ğŸ”ˆ éŸ³ã‚’æœ‰åŠ¹åŒ–
                </button>
            </div>
        </div>

        <!-- ã‚³ãƒ³ãƒ†ãƒ³ãƒ„é ˜åŸŸ -->
        <div class="content">
            <!-- ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ç”»é¢ -->
            <div class="screen active" id="screenMessage">
                <div class="panel">
                    <div class="message-header">
                        <div class="message-header__left">
                            <div class="avatar">æ¯</div>
                            <div class="sender-name">æ¯å­ã‚ˆã‚Š</div>
                        </div>
                        <div class="message-time">æœ¬æ—¥ 11:25</div>
                    </div>
                    <div class="message-body-wrapper">
                        <div class="message-body" id="messageBody">
                            ã“ã‚“ã«ã¡ã¯ã€‚<br />
                            ä»Šæ—¥ã®ä½“èª¿ã¯ã„ã‹ãŒã§ã™ã‹ï¼Ÿ<br /><br />
                            å¾Œã»ã©é›»è©±ã—ã¦ã‚‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ
                        </div>
                        <div class="nav-buttons nav-buttons--overlay">
                            <button class="btn btn-secondary btn-disabled" id="btnPrevMsg" disabled>
                                â¬…ï¸ å‰ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
                            </button>
                            <button class="btn btn-secondary btn-disabled" id="btnNextMsg" disabled>
                                â¡ï¸ æ¬¡ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
                            </button>
                        </div>
                        <div class="status-text response-status-overlay" id="responseStatusIndicator" style="display: none;">
                            <!-- æœªå›ç­”/å›ç­”æ¸ˆã¿ã®çŠ¶æ…‹ã‚’è¡¨ç¤º -->
                        </div>
                    </div>

                    <div class="message-footer">
                        <div class="response-buttons">
                            <button class="btn btn-large btn-success" id="btnOk">
                                å•é¡Œã‚ã‚Šã¾ã›ã‚“
                            </button>
                            <button class="btn btn-large btn-primary" id="btnCallLater">
                                å¾Œã»ã©è©±ã—ã¾ã™
                            </button>
                            <button class="btn btn-large btn-secondary" id="btnAck">
                                ğŸ“– èª­ã¿ã¾ã—ãŸ
                            </button>
                        </div>
                        <div class="status-text" id="responseStatus">
                            <!-- ã“ã“ã«ã€Œé€ä¿¡ã—ã¾ã—ãŸã€ãªã©ã‚’è¡¨ç¤º -->
                        </div>
                    </div>
                </div>
            </div>

            <!-- ãƒ•ã‚©ãƒˆãƒ•ãƒ¬ãƒ¼ãƒ ç”»é¢ -->
            <div class="screen" id="screenPhoto">
                <div class="photo-frame" id="photoFrame">
                    <img id="photoImage" class="photo-image" src="" alt="ã‚¹ãƒ©ã‚¤ãƒ‰ã‚·ãƒ§ãƒ¼ç”»åƒ" />
                    <div class="message-indicator" id="photoMessageIndicator">
                        <span class="unread-icon" aria-hidden="true">ğŸ—¨ï¸</span>
                        <span id="photoUnreadBadgeText">æ–°ç€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ 1ä»¶</span>
                    </div>
                </div>
            </div>

        </div>

        <!-- ä¸‹éƒ¨ãƒŠãƒ“ -->
        <div class="bottom-nav">
            <button class="bottom-nav__button" id="navMessage">
                <span class="bottom-nav__icon">ğŸ—¨ï¸</span>
                <span>ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸</span>
            </button>
            <button class="bottom-nav__button bottom-nav__button--active" id="navPhoto">
                <span class="bottom-nav__icon">ğŸ–¼ï¸</span>
                <span>å†™çœŸã‚’è¦‹ã‚‹</span>
            </button>
        </div>
    </div>

    <script>
        const DEVICE_ID = "home-parents-1";
        const DEFAULT_PROXY_BASE = "http://localhost:8080";
        const PROXY_BASE =
            location.protocol === "file:" || location.origin === "null"
                ? DEFAULT_PROXY_BASE
                : location.origin;
        const SINCE_KEY = "kiosk_since_ms";
        const NOTIFY_SOUND_COOLDOWN_MS = 2000;
        const NOTIFY_SOUND_HISTORY_CUTOFF_MS = 5 * 60 * 1000;
        let audioCtx = null;
        let audioUnlocked = false;
        let audioWarned = false;
        let lastBeepAt = 0;

        // ==========================
        // ä»®ã®ç”»åƒãƒªã‚¹ãƒˆï¼ˆå°†æ¥ã¯ã‚µãƒ¼ãƒã‹ã‚‰å–å¾—ï¼‰
        // ==========================
        let photoList = [];
        let currentPhotoIndex = 0;
        let slideShowTimer = null;
        const slideIntervalMs = 15000;

        const photoImage = document.getElementById("photoImage");
        const btnEnableSound = document.getElementById("btnEnableSound");

        // Cloud Run ã«ãƒ‡ãƒ—ãƒ­ã‚¤ã—ãŸURLã‚’ã“ã“ã«
        // ãƒ­ãƒ¼ã‚«ãƒ«ãªã‚‰ "http://localhost:8080/api/photos"
        // const PHOTO_API_URL = "https://photo-api-mock-162530971346.asia-northeast1.run.app/api/photos";
        const PHOTO_API_URL = `${PROXY_BASE}/api/photos`;
        
        async function fetchPhotos() {
            try {
                const res = await fetch(PHOTO_API_URL);
                if (!res.ok) {
                    throw new Error(`HTTP error ${res.status}`);
                }
                const data = await res.json();
                if (!Array.isArray(data) || data.length === 0) {
                    console.warn("photo list is empty");
                    return;
                }
                photoList = data;
                currentPhotoIndex = 0;
                // ã„ã¾ãƒ•ã‚©ãƒˆç”»é¢ãªã‚‰ã™ãã‚¹ãƒ©ã‚¤ãƒ‰ã‚·ãƒ§ãƒ¼é–‹å§‹
                if (screens.photo.classList.contains("active")) {
                    startSlideShow();
                }
            } catch (err) {
                console.error("Failed to fetch photos:", err);
            }
        }

        function resolvePhotoUrl(url) {
            if (!url) return "";
            if (url.startsWith("/")) {
                const base = PROXY_BASE.endsWith("/") ? PROXY_BASE.slice(0, -1) : PROXY_BASE;
                return `${base}${url}`;
            }
            return url;
        }

        function showPhoto(index) {
            if (!photoList.length) return;
            const photo = photoList[index % photoList.length];
            currentPhotoIndex = index % photoList.length;

            photoImage.src = resolvePhotoUrl(photo.url);
        }

        // èµ·å‹•æ™‚ã«ä¸€å›å–å¾—
        fetchPhotos();

        function ensureAudioContext() {
            if (!audioCtx) {
                const AudioCtx = window.AudioContext || window.webkitAudioContext;
                if (!AudioCtx) return null;
                audioCtx = new AudioCtx();
            }
            return audioCtx;
        }

        function unlockAudioContext() {
            const ctx = ensureAudioContext();
            if (!ctx) return;
            if (ctx.state === "suspended") {
                ctx.resume().catch(() => {});
            }
            audioUnlocked = true;
        }

        function updateSoundUi() {
            if (!btnEnableSound) return;
            const ctx = ensureAudioContext();
            if (!ctx) {
                btnEnableSound.textContent = "ğŸ”‡ éŸ³å£°éå¯¾å¿œ";
                btnEnableSound.disabled = true;
                return;
            }
            if (audioUnlocked) {
                btnEnableSound.textContent = "ğŸ”” éŸ³ON";
                btnEnableSound.disabled = true;
                btnEnableSound.style.display = "none";
                return;
            }
            btnEnableSound.textContent = "ğŸ”ˆ éŸ³ã‚’æœ‰åŠ¹åŒ–";
            btnEnableSound.disabled = false;
            btnEnableSound.style.display = "inline-flex";
        }

        function playNotifyMelody() {
            if (!audioUnlocked) {
                updateSoundUi();
                return;
            }
            const ctx = ensureAudioContext();
            if (!ctx) {
                if (!audioWarned) {
                    console.warn("AudioContext is not supported in this browser.");
                    audioWarned = true;
                }
                return;
            }
            const now = Date.now();
            if (now - lastBeepAt < NOTIFY_SOUND_COOLDOWN_MS) return;
            lastBeepAt = now;

            const notes = [
                { freq: 880, dur: 0.32 }, // A5
                { freq: 660, dur: 0.32 }, // E5
                { freq: 1046, dur: 0.36 }, // C6
                { freq: 880, dur: 0.32 }, // A5
                { freq: 660, dur: 0.32 }, // E5
                { freq: 1175, dur: 0.42 }, // D6
            ];
            const gap = 0.08;
            const masterGain = ctx.createGain();
            const compressor = ctx.createDynamicsCompressor();
            masterGain.gain.value = 0.32;
            compressor.threshold.setValueAtTime(-18, ctx.currentTime);
            compressor.ratio.setValueAtTime(8, ctx.currentTime);
            compressor.attack.setValueAtTime(0.003, ctx.currentTime);
            compressor.release.setValueAtTime(0.2, ctx.currentTime);
            masterGain.connect(compressor);
            compressor.connect(ctx.destination);

            let t = ctx.currentTime + 0.01;
            notes.forEach((note, index) => {
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = "triangle";
                osc.frequency.value = note.freq;
                gain.gain.setValueAtTime(0.0001, t);
                gain.gain.exponentialRampToValueAtTime(0.25, t + 0.03);
                gain.gain.exponentialRampToValueAtTime(0.0001, t + note.dur);
                osc.connect(gain);
                gain.connect(masterGain);
                osc.start(t);
                osc.stop(t + note.dur + 0.04);
                t += note.dur + gap;

                if (index === 2) {
                    t += 0.18;
                }
            });
        }

        function setupAudioUnlock() {
            const unlock = () => {
                unlockAudioContext();
                updateSoundUi();
                document.removeEventListener("click", unlock);
                document.removeEventListener("touchstart", unlock);
                document.removeEventListener("keydown", unlock);
            };
            document.addEventListener("click", unlock);
            document.addEventListener("touchstart", unlock);
            document.addEventListener("keydown", unlock);
        }

        setupAudioUnlock();
        updateSoundUi();

        if (btnEnableSound) {
            btnEnableSound.addEventListener("click", () => {
                unlockAudioContext();
                playNotifyMelody();
                updateSoundUi();
            });
        }

        function parseEventTimeMs(value) {
            if (!value) return null;
            if (typeof value === "number") return value;
            const num = Number(value);
            if (!Number.isNaN(num)) return num;
            const date = new Date(value);
            return Number.isNaN(date.getTime()) ? null : date.getTime();
        }


        function nextPhoto() {
            showPhoto(currentPhotoIndex + 1);
        }

        function prevPhoto() {
            if (currentPhotoIndex === 0) {
                showPhoto(photoList.length - 1);
            } else {
                showPhoto(currentPhotoIndex - 1);
            }
        }

        function startSlideShow() {
            // ã™ã§ã«å‹•ã„ã¦ã„ãŸã‚‰ä¸€æ—¦ã‚¯ãƒªã‚¢
            stopSlideShow();
            // ã„ã¾ã®ç”»åƒã‚’è¡¨ç¤ºï¼ˆåˆå›è¡¨ç¤ºorå†é–‹æ™‚ï¼‰
            showPhoto(currentPhotoIndex);
            // ä¸€å®šé–“éš”ã§åˆ‡ã‚Šæ›¿ãˆ
            slideShowTimer = setInterval(nextPhoto, slideIntervalMs);
        }

        function stopSlideShow() {
            if (slideShowTimer) {
                clearInterval(slideShowTimer);
                slideShowTimer = null;
            }
        }

        // ãƒ•ã‚©ãƒˆãƒ•ãƒ¬ãƒ¼ãƒ ã®ã‚¿ãƒƒãƒ—æ“ä½œ
        const photoFrame = document.getElementById("photoFrame");
        photoFrame.addEventListener("click", (event) => {
            const rect = photoFrame.getBoundingClientRect();
            const clickX = event.clientX - rect.left;
            const width = rect.width;
            
            // å·¦å´30%ã‚’ã‚¿ãƒƒãƒ— â†’ å‰ã®å†™çœŸ
            if (clickX < width * 0.3) {
                prevPhoto();
                // è‡ªå‹•é€ã‚Šã‚’ãƒªã‚»ãƒƒãƒˆ
                if (slideShowTimer) {
                    startSlideShow();
                }
            } 
            // å³å´30%ã‚’ã‚¿ãƒƒãƒ— â†’ æ¬¡ã®å†™çœŸ
            else if (clickX > width * 0.7) {
                nextPhoto();
                // è‡ªå‹•é€ã‚Šã‚’ãƒªã‚»ãƒƒãƒˆ
                if (slideShowTimer) {
                    startSlideShow();
                }
            }
            // ä¸­å¤®40%ã¯ä½•ã‚‚ã—ãªã„
        });

        // ç”»é¢åˆ‡ã‚Šæ›¿ãˆãƒ­ã‚¸ãƒƒã‚¯ï¼ˆå‰å›ã®ã‚‚ã®ã«è¿½è¨˜ã™ã‚‹å½¢ï¼‰
        const screens = {
            message: document.getElementById("screenMessage"),
            photo: document.getElementById("screenPhoto"),
        };

        const MESSAGE_IDLE_TIMEOUT_MS = 60 * 1000;
        let messageIdleTimer = null;

        function isMessageScreenActive() {
            return screens.message.classList.contains("active");
        }

        function stopMessageIdleTimer() {
            if (messageIdleTimer) {
                clearTimeout(messageIdleTimer);
                messageIdleTimer = null;
            }
        }

        function startMessageIdleTimer() {
            stopMessageIdleTimer();
            if (!isMessageScreenActive()) return;
            messageIdleTimer = setTimeout(() => {
                if (isMessageScreenActive()) {
                    setActiveScreen("photo");
                }
            }, MESSAGE_IDLE_TIMEOUT_MS);
        }

        function resetMessageIdleTimer() {
            if (!isMessageScreenActive()) return;
            startMessageIdleTimer();
        }

        const bottomNavButtons = {
            message: document.getElementById("navMessage"),
            photo: document.getElementById("navPhoto"),
        };

        const topUnreadBadge = document.getElementById("topUnreadBadge");
        const topUnreadBadgeText = document.getElementById("topUnreadBadgeText");
        const photoMessageIndicator = document.getElementById("photoMessageIndicator");
        const photoUnreadBadgeText = document.getElementById("photoUnreadBadgeText");
        const responseStatus = document.getElementById("responseStatus");
        const responseStatusIndicator = document.getElementById("responseStatusIndicator");
        const choiceButtons = {
            primary: document.getElementById("btnOk"),
            secondary: document.getElementById("btnCallLater"),
            tertiary: document.getElementById("btnAck"),
        };
        let currentChoices = {
            choice1: "å•é¡Œã‚ã‚Šã¾ã›ã‚“",
            choice2: "å¾Œã»ã©è©±ã—ã¾ã™",
            choice3: "èª­ã¿ã¾ã—ãŸ",
            reasoning: "",
        };

        function applyChoiceButtons(choices) {
            const c1 = choices.choice1 || "å•é¡Œã‚ã‚Šã¾ã›ã‚“";
            const c2 = choices.choice2 || "å¾Œã»ã©è©±ã—ã¾ã™";
            const c3 = choices.choice3 || "èª­ã¿ã¾ã—ãŸ";
            currentChoices = {
                choice1: c1,
                choice2: c2,
                choice3: c3,
                reasoning: choices.reasoning || "",
            };
            choiceButtons.primary.textContent = `${c1}`;
            choiceButtons.secondary.textContent = `${c2}`;
            choiceButtons.tertiary.textContent = `ğŸ“– ${c3}`;
        }

        function setActiveScreen(name) {
            Object.values(screens).forEach((el) => el.classList.remove("active"));
            screens[name].classList.add("active");

            Object.values(bottomNavButtons).forEach((btn) =>
                btn.classList.remove("bottom-nav__button--active")
            );
            bottomNavButtons[name].classList.add("bottom-nav__button--active");

            // ãƒ•ã‚©ãƒˆãƒ•ãƒ¬ãƒ¼ãƒ è¡¨ç¤ºä¸­ã ã‘ã‚¹ãƒ©ã‚¤ãƒ‰ã‚·ãƒ§ãƒ¼ã‚’å‹•ã‹ã™
            if (name === "photo") {
                startSlideShow();
            } else {
                stopSlideShow();
            }

            if (name === "message") {
                startMessageIdleTimer();
            } else {
                stopMessageIdleTimer();
            }
        }

        bottomNavButtons.message.addEventListener("click", () => setActiveScreen("message"));
        bottomNavButtons.photo.addEventListener("click", () => setActiveScreen("photo"));

        ["pointerdown", "touchstart", "keydown"].forEach((eventName) => {
            document.addEventListener(eventName, () => {
                resetMessageIdleTimer();
            });
        });

        startMessageIdleTimer();

        choiceButtons.primary.addEventListener("click", () => {
            sendLineReply(currentChoices.choice1);
        });

        choiceButtons.secondary.addEventListener("click", () => {
            sendLineReply(currentChoices.choice2);
        });

        choiceButtons.tertiary.addEventListener("click", () => {
            sendLineReply(currentChoices.choice3);
        });

        document.getElementById("btnPrevMsg").addEventListener("click", () => {
            if (currentMessageIndex > 0) {
                renderMessageByIndex(currentMessageIndex - 1);
            }
        });
        document.getElementById("btnNextMsg").addEventListener("click", () => {
            if (currentMessageIndex < messageHistory.length - 1) {
                renderMessageByIndex(currentMessageIndex + 1);
            }
        });

        function clearUnreadIndicators() {
            // æ—§ä»•æ§˜ã®äº’æ›: å‘¼ã°ã‚Œã¦ã‚‚æœªå›ç­”ä»¶æ•°ã§è¡¨ç¤ºã‚’å†è¨ˆç®—ã™ã‚‹
            updateUnansweredIndicators();
        }

        function getUnansweredCount() {
            // messageHistory å†…ã§ã€Œæœªå›ç­”ã€ã®ä»¶æ•°ã‚’æ•°ãˆã‚‹
            let count = 0;
            for (const evt of messageHistory) {
                const id = getMessageId(evt);
                if (!id) continue;
                if (!getReplyState(id)) count++;
            }
            return count;
        }

        function updateUnansweredIndicators() {
            const count = getUnansweredCount();
            if (count > 0) {
                const text = `æ–°ç€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ ${count}ä»¶`;
                topUnreadBadge.style.display = "inline-flex";
                if (topUnreadBadgeText) topUnreadBadgeText.textContent = text;
                photoMessageIndicator.style.display = "flex";
                if (photoUnreadBadgeText) photoUnreadBadgeText.textContent = text;
            } else {
                topUnreadBadge.style.display = "none";
                photoMessageIndicator.style.display = "none";
            }
        }

        // ==========================
        // SSE (through local proxy)
        // ==========================
        const messageBody = document.getElementById("messageBody");
        const senderNameEl = document.querySelector(".sender-name");
        const avatarEl = document.querySelector(".avatar");
        const messageTimeEl = document.querySelector(".message-time");
        let currentLineContext = {
            routeId: null,
            quoteToken: null,
            messageId: null,
            sourceType: null,
            senderName: null,
            sourceText: null,
            createdAt: null,
        };

        // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å±¥æ­´ç®¡ç†
        let messageHistory = [];
        let currentMessageIndex = -1;
        
        // å›ç­”çŠ¶æ…‹ã®ç®¡ç†ï¼ˆlocalStorageã«ä¿å­˜ï¼‰
        const REPLY_STORAGE_KEY = "kiosk_replies";
        const replyStateCache = new Map();
        
        function getMessageId(evt) {
            return evt.eventId || evt.id || evt.line?.messageId || null;
        }
        
        function normalizeReplyState(raw) {
            if (!raw || typeof raw !== "object") return null;
            const choiceText = raw.choiceText || raw.text || null;
            if (!choiceText) return null;
            const repliedAt = Number(raw.repliedAt) || null;
            return {
                choiceText,
                repliedAt: repliedAt || Date.now(),
            };
        }
        
        function getReplyState(messageId) {
            if (!messageId) return null;
            try {
                if (replyStateCache.has(messageId)) {
                    return replyStateCache.get(messageId);
                }
                const replies = JSON.parse(localStorage.getItem(REPLY_STORAGE_KEY) || "{}");
                const state = replies[messageId] || null;
                if (state) {
                    replyStateCache.set(messageId, state);
                }
                return state;
            } catch (err) {
                console.error("Failed to get reply state:", err);
                return null;
            }
        }
        
        function saveReplyState(messageId, choiceText, repliedAt) {
            if (!messageId) return;
            try {
                const replies = JSON.parse(localStorage.getItem(REPLY_STORAGE_KEY) || "{}");
                replies[messageId] = {
                    choiceText,
                    repliedAt: repliedAt || Date.now(),
                };
                localStorage.setItem(REPLY_STORAGE_KEY, JSON.stringify(replies));
                replyStateCache.set(messageId, replies[messageId]);
            } catch (err) {
                console.error("Failed to save reply state:", err);
            }
        }
        
        function applyReplyStateFromEvent(evt) {
            const messageId = getMessageId(evt);
            if (!messageId) return null;
            const replyState = normalizeReplyState(evt.reply);
            if (replyState) {
                saveReplyState(messageId, replyState.choiceText, replyState.repliedAt);
                return replyState;
            }
            return null;
        }

        function addMessageToHistory(evt) {
            // é‡è¤‡ãƒã‚§ãƒƒã‚¯ï¼ˆåŒã˜eventIdã‚„messageIdã®å ´åˆã¯è¿½åŠ ã—ãªã„ï¼‰
            const eventId = evt.eventId || evt.id;
            const messageId = evt.line?.messageId;
            const exists = messageHistory.some(msg => 
                (eventId && msg.eventId === eventId) || 
                (messageId && msg.line?.messageId === messageId)
            );
            
            if (!exists) {
                messageHistory.push(evt);
                // ä½œæˆæ—¥æ™‚ã§ã‚½ãƒ¼ãƒˆï¼ˆå¤ã„é †ï¼‰
                messageHistory.sort((a, b) => {
                    const timeA = a.createdAt ? new Date(a.createdAt).getTime() : 0;
                    const timeB = b.createdAt ? new Date(b.createdAt).getTime() : 0;
                    return timeA - timeB;
                });
                // æœ€æ–°ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ï¼ˆæœ€å¾Œã®è¦ç´ ï¼‰ã«ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¨­å®š
                currentMessageIndex = messageHistory.length - 1;
            }
            applyReplyStateFromEvent(evt);
            updateUnansweredIndicators();
            return !exists;
        }

        function normalizeSenderName(name) {
            return String(name || "")
                .replace(/\u3000/g, " ") // å…¨è§’ã‚¹ãƒšãƒ¼ã‚¹ â†’ åŠè§’
                .replace(/\s+/g, " ")
                .trim();
        }

        function mapSender(senderRaw) {
            const normalized = normalizeSenderName(senderRaw);
            const lower = normalized.toLowerCase();

            // æŒ‡å®šãƒãƒƒãƒ”ãƒ³ã‚°
            if (lower === "nekia") return { displayName: "ã‚ã¤ã—", avatar: "ã‚" };
            if (normalized === "ãŸãªã‹ ã‚†ã†ã“") return { displayName: "ã‚†ã†ã“", avatar: "ã‚†" };
            if (lower === "kenichi") return { displayName: "ã‘ã‚“ã„ã¡", avatar: "ã‘" };
            if (normalized === "æ ¹æœ¨ æ•™ç”·") return { displayName: "ã®ã‚ŠãŠ", avatar: "ã®" };
            if (normalized === "ç”°ä¸­ èª‰å¤§") return { displayName: "ãŸã‹ã²ã‚", avatar: "ãŸ" };

            // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ãã®ã¾ã¾è¡¨ç¤ºã€ã‚¢ãƒã‚¿ãƒ¼ã¯å…ˆé ­1æ–‡å­—
            const displayName = normalized || "ï¼ˆä¸æ˜ï¼‰";
            const avatar = displayName.slice(0, 1);
            return { displayName, avatar };
        }

        function getRelativeTimeLabel(date) {
            if (!date || Number.isNaN(date.getTime())) return "";
            const now = new Date();
            const diffMs = now - date;
            if (diffMs <= 30 * 1000) return "ä»Š";
            const diffMinutes = Math.floor(diffMs / (60 * 1000));
            if (diffMinutes < 60) return `${diffMinutes}åˆ†å‰`;
            const diffHours = Math.floor(diffMs / (60 * 60 * 1000));
            if (diffHours < 24) return `${diffHours}æ™‚é–“å‰`;

            const startOfToday = new Date(now.getFullYear(), now.getMonth(), now.getDate());
            const startOfDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());
            const diffDays = Math.floor((startOfToday - startOfDate) / (24 * 60 * 60 * 1000));
            if (diffDays === 1) return "æ˜¨æ—¥";
            if (diffDays > 1) return `${diffDays}æ—¥å‰`;
            return "ä»Š";
        }

        function buildImageProxyUrl(url) {
            if (!url) return "";
            const base = PROXY_BASE.endsWith("/") ? PROXY_BASE.slice(0, -1) : PROXY_BASE;
            return `${base}/api/image-proxy?url=${encodeURIComponent(url)}`;
        }

        function renderMessageBody(imageUrl, text) {
            const hasImage = Boolean(imageUrl);
            const hasText = Boolean(text && text.trim());
            messageBody.innerHTML = "";
            messageBody.classList.remove("message-body--image-only", "message-body--has-text");

            if (hasImage) {
                const proxyUrl = buildImageProxyUrl(imageUrl);
                const img = document.createElement("img");
                img.className = "message-image";
                img.alt = hasText ? `å†™çœŸ: ${text}` : "å—ä¿¡ã—ãŸå†™çœŸ";
                img.loading = "lazy";
                img.referrerPolicy = "no-referrer";
                img.addEventListener("error", () => {
                    messageBody.setAttribute("data-image-error", "true");
                });
                img.src = proxyUrl || imageUrl;
                messageBody.appendChild(img);
            }

            if (hasText) {
                const textEl = document.createElement("div");
                textEl.className = "message-text";
                textEl.textContent = text;
                messageBody.appendChild(textEl);
            }

            if (!hasImage && !hasText) {
                messageBody.textContent = "ï¼ˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æœ¬æ–‡ãªã—ï¼‰";
            }

            if (hasImage && !hasText) {
                messageBody.classList.add("message-body--image-only");
            } else if (hasImage && hasText) {
                messageBody.classList.add("message-body--has-text");
            }
        }

        function renderMessage(evt) {
            const payload = evt.payload || {};
            const line = evt.line || {};
            const text = payload.text || "";
            const imageUrl = payload.imageUrl || payload?.image?.url || "";
            const senderRaw = payload.senderName || line.senderName || "ï¼ˆä¸æ˜ï¼‰";
            const senderMapped = mapSender(senderRaw);
            const createdAt = evt.createdAt ? new Date(evt.createdAt) : new Date();
            const gemini = evt.gemini || {};

            const routeId = line.routeId || line.groupId || line.roomId || line.userId || null;
            const messageId = getMessageId(evt);
            currentLineContext = {
                routeId,
                quoteToken: line.quoteToken || null,
                messageId: line.messageId || null,
                sourceType: line.sourceType || line.type || null,
                senderName: senderMapped.displayName,
                sourceText: text,
                createdAt: createdAt.toLocaleString("ja-JP"),
            };

            renderMessageBody(imageUrl, text);
            senderNameEl.textContent = senderMapped.displayName;
            if (avatarEl) avatarEl.textContent = senderMapped.avatar;
            const relativeLabel = getRelativeTimeLabel(createdAt);
            messageTimeEl.textContent = relativeLabel
                ? `${createdAt.toLocaleString("ja-JP")}ï¼ˆ${relativeLabel}ï¼‰`
                : createdAt.toLocaleString("ja-JP");
            updateUnansweredIndicators();
            
            // å›ç­”çŠ¶æ…‹ã‚’ç¢ºèªã—ã¦è¡¨ç¤ºã‚’æ›´æ–°
            const replyState = applyReplyStateFromEvent(evt) || getReplyState(messageId);
            updateResponseUI(evt, replyState, gemini);
        }
        
        function updateResponseUI(evt, replyState, gemini) {
            const messageId = getMessageId(evt);
            
            // ã¾ãšé¸æŠè‚¢ãƒœã‚¿ãƒ³ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’è¨­å®šï¼ˆå›ç­”æ¸ˆã¿/æœªå›ç­”ã«é–¢ã‚ã‚‰ãšï¼‰
            applyChoiceButtons(gemini);

            const allButtons = [choiceButtons.primary, choiceButtons.secondary, choiceButtons.tertiary];
            const resetButtonStyles = () => {
                allButtons.forEach((btn) => {
                    btn.style.opacity = "1";
                    btn.style.border = "";
                    btn.classList.remove("btn-selected");
                });
            };
            
            if (replyState) {
                // å›ç­”æ¸ˆã¿ã®å ´åˆ
                responseStatus.textContent = "";
                responseStatusIndicator.style.display = "block";
                responseStatusIndicator.className = "status-text response-status-overlay response-status-answered";
                responseStatusIndicator.textContent = "âœ… å›ç­”æ¸ˆã¿";
                
                // ãƒœã‚¿ãƒ³ã‚’ç„¡åŠ¹åŒ–
                allButtons.forEach((btn) => {
                    btn.disabled = true;
                    btn.classList.add("btn-disabled");
                });
                
                // é¸æŠã—ãŸå›ç­”ã‚’å¼·èª¿è¡¨ç¤º
                const selectedText = replyState.choiceText;
                // ãƒœã‚¿ãƒ³ã®ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰çµµæ–‡å­—ã‚’é™¤ã„ã¦æ¯”è¼ƒ
                const primaryText = choiceButtons.primary.textContent.trim();
                const secondaryText = choiceButtons.secondary.textContent.trim();
                const tertiaryText = choiceButtons.tertiary.textContent.replace(/^ğŸ“–\s*/, "").trim();
                
                resetButtonStyles();
                const selectedIndex =
                    primaryText === selectedText ? 0 :
                    secondaryText === selectedText ? 1 :
                    tertiaryText === selectedText ? 2 :
                    -1;
                if (selectedIndex >= 0) {
                    allButtons.forEach((btn, idx) => {
                        if (idx === selectedIndex) {
                            btn.style.opacity = "1";
                            btn.classList.add("btn-selected");
                        } else {
                            btn.style.opacity = "0.5";
                        }
                    });
                }
            } else {
                // æœªå›ç­”ã®å ´åˆ
                responseStatus.textContent = "";
                responseStatusIndicator.style.display = "block";
                responseStatusIndicator.className = "status-text response-status-overlay response-status-unanswered";
                responseStatusIndicator.innerHTML = '<span class="unanswered-badge">æœªå›ç­”</span><span>å›ç­”ã‚’ãŠå¾…ã¡ã—ã¦ã„ã¾ã™</span>';
                
                // ãƒœã‚¿ãƒ³ã‚’æœ‰åŠ¹åŒ–
                allButtons.forEach((btn) => {
                    btn.disabled = false;
                    btn.classList.remove("btn-disabled");
                });
                
                // ãƒœã‚¿ãƒ³ã®ã‚¹ã‚¿ã‚¤ãƒ«ã‚’ãƒªã‚»ãƒƒãƒˆ
                resetButtonStyles();
            }
        }

        function renderMessageByIndex(index) {
            if (index < 0 || index >= messageHistory.length) {
                return;
            }
            const evt = messageHistory[index];
            currentMessageIndex = index;
            renderMessage(evt);
            updateNavigationButtons();
        }

        function updateNavigationButtons() {
            const btnPrev = document.getElementById("btnPrevMsg");
            const btnNext = document.getElementById("btnNextMsg");
            
            // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å±¥æ­´ãŒç©ºã®å ´åˆã¯ä¸¡æ–¹ã¨ã‚‚ç„¡åŠ¹
            if (messageHistory.length === 0) {
                btnPrev.disabled = true;
                btnPrev.classList.add("btn-disabled");
                btnNext.disabled = true;
                btnNext.classList.add("btn-disabled");
                return;
            }
            
            // å‰ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒœã‚¿ãƒ³
            if (currentMessageIndex > 0) {
                btnPrev.disabled = false;
                btnPrev.classList.remove("btn-disabled");
            } else {
                btnPrev.disabled = true;
                btnPrev.classList.add("btn-disabled");
            }
            
            // æ¬¡ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒœã‚¿ãƒ³
            if (currentMessageIndex < messageHistory.length - 1) {
                btnNext.disabled = false;
                btnNext.classList.remove("btn-disabled");
            } else {
                btnNext.disabled = true;
                btnNext.classList.add("btn-disabled");
            }
        }

        function showLatestMessage() {
            if (messageHistory.length > 0) {
                renderMessageByIndex(messageHistory.length - 1);
            } else {
                // å±¥æ­´ãŒç©ºã®å ´åˆã¯ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³ã‚’ç„¡åŠ¹ã«ã™ã‚‹ã ã‘
                updateNavigationButtons();
            }
        }

        function isUnreadMessage(evt) {
            if (!evt) return false;
            const messageId = getMessageId(evt);
            if (!messageId) return false;
            const replyState = applyReplyStateFromEvent(evt) || getReplyState(messageId);
            return !replyState;
        }

        function moveToNextUnreadMessage() {
            if (messageHistory.length === 0) return;
            for (let i = currentMessageIndex + 1; i < messageHistory.length; i += 1) {
                if (isUnreadMessage(messageHistory[i])) {
                    renderMessageByIndex(i);
                    return;
                }
            }
            for (let i = 0; i < currentMessageIndex; i += 1) {
                if (isUnreadMessage(messageHistory[i])) {
                    renderMessageByIndex(i);
                    return;
                }
            }
        }

        async function sendLineReply(choiceText) {
            if (!currentLineContext.routeId) {
                responseStatus.textContent = "é€ä¿¡å…ˆãŒä¸æ˜ã§ã™ï¼ˆrouteIdãªã—ï¼‰";
                return;
            }
            
            const messageId = getMessageId(messageHistory[currentMessageIndex]);
            if (!messageId) {
                responseStatus.textContent = "ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸IDãŒä¸æ˜ã§ã™";
                return;
            }
            
            const body = {
                deviceId: DEVICE_ID,
                text: choiceText,
                line: currentLineContext,
            };

            responseStatus.textContent = "é€ä¿¡ä¸­...";
            choiceButtons.primary.disabled = true;
            choiceButtons.secondary.disabled = true;
            choiceButtons.tertiary.disabled = true;

            try {
                const res = await fetch(`${PROXY_BASE}/api/line/reply`, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(body),
                });
                if (!res.ok) {
                    const errText = await res.text();
                    throw new Error(`HTTP ${res.status}: ${errText}`);
                }
                
                // å›ç­”çŠ¶æ…‹ã‚’ä¿å­˜
                saveReplyState(messageId, choiceText);
                
                // ãƒ¡ãƒ¢ãƒªä¸Šã®å±¥æ­´ã«ã‚‚åæ˜ 
                const evt = messageHistory[currentMessageIndex];
                if (evt) {
                    evt.reply = { choiceText, repliedAt: Date.now() };
                }
                
                // UIã‚’æ›´æ–°ï¼ˆå›ç­”æ¸ˆã¿çŠ¶æ…‹ã‚’è¡¨ç¤ºï¼‰
                updateResponseUI(evt, { choiceText, repliedAt: Date.now() }, evt.gemini || {});
                
                updateUnansweredIndicators();
                moveToNextUnreadMessage();
            } catch (err) {
                console.error("failed to send reply", err);
                responseStatus.textContent = `é€ä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸ: ${err.message}`;
                // ã‚¨ãƒ©ãƒ¼æ™‚ã¯ãƒœã‚¿ãƒ³ã‚’å†åº¦æœ‰åŠ¹åŒ–
                choiceButtons.primary.disabled = false;
                choiceButtons.secondary.disabled = false;
                choiceButtons.tertiary.disabled = false;
                choiceButtons.primary.classList.remove("btn-disabled");
                choiceButtons.secondary.classList.remove("btn-disabled");
                choiceButtons.tertiary.classList.remove("btn-disabled");
            }
        }

        let eventSource = null;
        function buildSseUrl(loadHistory = false) {
            const params = new URLSearchParams({ deviceId: DEVICE_ID });
            const since = localStorage.getItem(SINCE_KEY);
            
            if (loadHistory || !since) {
                // éå»1é€±é–“å‰ã®ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã‚’è¨ˆç®—
                const oneWeekAgo = Date.now() - (7 * 24 * 60 * 60 * 1000);
                params.set("since", oneWeekAgo.toString());
            } else {
                // å†æ¥ç¶šæ™‚ã¯ä¿å­˜ã•ã‚Œã¦ã„ã‚‹sinceå€¤ã‚’ä½¿ç”¨ï¼ˆæ–°ã—ã„ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ã¿ï¼‰
                params.set("since", since);
            }
            
            return `${PROXY_BASE}/sse?${params.toString()}`;
        }

        function startEventStream(loadHistory = false) {
            if (eventSource) {
                eventSource.close();
                eventSource = null;
            }
            const connectionStartedAt = Date.now();
            
            // å±¥æ­´ã‚’èª­ã¿è¾¼ã‚€å ´åˆã¯ã€æ—¢å­˜ã®å±¥æ­´ã‚’ã‚¯ãƒªã‚¢
            if (loadHistory) {
                messageHistory = [];
                currentMessageIndex = -1;
                updateNavigationButtons();
            }
            
            const url = buildSseUrl(loadHistory);
            console.log("Connecting to SSE:", url);
            eventSource = new EventSource(url);

            eventSource.addEventListener("open", () => {
                console.log("SSE connection opened");
            });

            // åˆæœŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å—ä¿¡ã‚’è¿½è·¡
            let initialMessagesReceived = false;
            let initialMessageTimeout = null;
            let initialMessageCount = 0;

            eventSource.addEventListener("kiosk_event", (ev) => {
                try {
                    const data = JSON.parse(ev.data);
                    const createdAtMs = parseEventTimeMs(data.createdAt);
                    const isHistoryEvent =
                        loadHistory &&
                        createdAtMs !== null &&
                        createdAtMs < connectionStartedAt - NOTIFY_SOUND_HISTORY_CUTOFF_MS;
                    const isNewMessage = data.type === "line_message";
                    const wasAdded = addMessageToHistory(data);
                    if (wasAdded && !isHistoryEvent && isNewMessage) {
                        playNotifyMelody();
                    }
                    initialMessageCount++;
                    
                    // åˆæœŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å—ä¿¡ãƒ•ãƒ©ã‚°ã‚’è¨­å®š
                    if (!initialMessagesReceived) {
                        initialMessagesReceived = true;
                        // åˆæœŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒå…¨ã¦æ¥ã‚‹ã¾ã§å°‘ã—å¾…ã£ã¦ã‹ã‚‰æœ€æ–°ã‚’è¡¨ç¤º
                        // éå»1é€±é–“ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å–å¾—ã™ã‚‹ãŸã‚ã€å°‘ã—é•·ã‚ã«å¾…ã¤
                        if (initialMessageTimeout) {
                            clearTimeout(initialMessageTimeout);
                        }
                        initialMessageTimeout = setTimeout(() => {
                            // æœ€æ–°ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
                            showLatestMessage();
                            console.log(`Loaded ${initialMessageCount} messages from history`);
                        }, 1000);
                    } else {
                        // æ–°ã—ã„ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒæ¥ãŸã‚‰å³åº§ã«æœ€æ–°ã‚’è¡¨ç¤º
                        showLatestMessage();
                    }
                    
                    const latest = data.createdAt || Date.now();
                    localStorage.setItem(SINCE_KEY, latest);
                } catch (err) {
                    console.error("failed to handle event", err);
                }
            });

            const errorHandler = (ev) => {
                const state = eventSource?.readyState;
                const stateText = state === 0 ? "CONNECTING" : state === 1 ? "OPEN" : state === 2 ? "CLOSED" : "UNKNOWN";
                console.error("SSE error:", {
                    readyState: state,
                    stateText,
                    url,
                    event: ev
                });
                
                // CLOSEDçŠ¶æ…‹ã®å ´åˆã¯æ¥ç¶šãŒå®Œå…¨ã«é–‰ã˜ã‚‰ã‚ŒãŸ
                if (state === 2) {
                    console.error("SSE connection closed. Check if proxy server is running and TARGET_BASE is configured correctly.");
                    // 5ç§’å¾Œã«å†æ¥ç¶šã‚’è©¦ã¿ã‚‹
                    setTimeout(() => {
                        console.log("Retrying SSE connection...");
                        startEventStream();
                    }, 5000);
                }
            };
            
            eventSource.addEventListener("error", errorHandler);
            eventSource.onerror = errorHandler;
        }

        // åˆå›æ¥ç¶šæ™‚ã¯éå»1é€±é–“ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’èª­ã¿è¾¼ã‚€
        startEventStream(true);

        // åˆæœŸè¡¨ç¤ºï¼šãƒ•ã‚©ãƒˆãƒ•ãƒ¬ãƒ¼ãƒ ç”»é¢
        setActiveScreen("photo");
        
        // ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³ã®åˆæœŸçŠ¶æ…‹ã‚’è¨­å®š
        updateNavigationButtons();
    </script>
</body>

</html>